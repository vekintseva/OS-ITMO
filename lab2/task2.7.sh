
#!/bin/bash

# массивы для считывания начальных и конечных данных, вывода pid и строк запуска
start_data=()
end_data=()
pids=()
startline=()

> task7.txt

# проходимся по всем pid из полного списка процессов
for pid in $(ps -axo pid | tail -n +2)

do
 if [[ -r /proc/$pid/io ]];then
# считываем стартовые данные
start_data[$pid]=$(grep -s "rchar" /proc/$pid/io | awk '{print $2}')
pids[$pid]=$pid
startline[$pid]=$(cat /proc/$pid/cmdline | tr -d '\0') 
fi
done

sleep 60

# проходимся по всем pid и считывем конечные данные
for pid in "${pids[@]}" 
do
end_data[$pid]=$(grep -s "rchar" /proc/$pid/io | awk '{print $2}')
done

# проходимся по всем pid и высчитываем и считаем максимальное количество байт из устройства хранения данных
for pid in "${pids[@]}"
do
diff=$(echo "${end_data[$pid]} - ${start_data[$pid]}" | bc)
echo $pid $diff ${startline[$pid]} >> task7.txt
done

sort -n -r -k 2 task7.txt | head -3 | awk '{print $1":"$3":"$2}'

#-le меньше или равно
#[-r ...] проверяет, что директория не пуста и в файле что-то есть
#io-файл, содержащий сведения об объемах данных, прочитанных и записанных процессом в хранилище
#grep -s не показывать сообщения об ошибках
#"rchar" для работы с подсчетом байт
#sleep 60 запускает команду через 60 сек с момента запуска скрипта
# tr-d - удаляем \0
# pids[@]-весь массив pids
#bc для конвертации между системами при совершении вычислений
# sort -n по числовому значению
#-r сортировка в обратном порядке (чтобы потом от большего к меньшему и взять при помощи head большее)
#-k указываем поле, по которому сортируем
